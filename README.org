#+title: Zrównoleglenie wstępnego przetwarzania danych przy użyciu Cuda
#+AUTHOR: Karol Wójcik, Krzysztof Swałdek
#+DATE: 2020-11-06, Piątek

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [12pt]
#+LATEX_HEADER: \usepackage[a4paper, inner=37.125mm, outer=33.4125mm, top=37.125mm, bottom=37.125mm, heightrounded, marginparwidth=51pt, marginparsep=17pt, headsep=24pt]{geometry}
#+EXCLUDE_TAGS: noexport
#+LATEX_HEADER: \usepackage{graphicx}
#+LaTeX_HEADER: \usepackage[T1]{fontenc}
#+LaTeX_HEADER: \usepackage{mathpazo}
#+LaTeX_HEADER: \linespread{1.05}
#+LATEX_HEADER: \usepackage{setspace}
#+LATEX_HEADER: \doublespacing
#+LATEX_HEADER: \usepackage[polish]{babel}
#+LATEX_HEADER: \usepackage{polski}
#+LATEX_HEADER: \usepackage{listings}
#+LaTeX_HEADER: \lstset{basicstyle=\small\ttfamily}
#+LaTeX_HEADER: \usepackage{alltt}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LaTeX_HEADER: \usepackage{moreverb}
#+LATEX_HEADER: \usepackage{ragged2e}
#+LATEX_HEADER: \usepackage{xltxtra}
#+LaTeX_HEADER: \usepackage{pdfpages}
#+OPTIONS: ^:{}
#+LANGUAGE: pl
#+OPTIONS: toc:nil

#+begin_export latex
  \clearpage \tableofcontents \clearpage
#+end_export

* Wprowadzenie
  Celem projektu jest implementacja popularnych algorytmów do przetwarzania danych, a także wykonanie i opis pomiaru czasowago wariantów algorytmów bez/z zrównolegleniem operując na środowisku MPI. \\

  \noindent
  W projekcie za wariant *A* uznaje się wersję algorytmu zrównoleglonego w c++.
  Za wersję *B* uznaje się wersję Pythonową algorytmu. \\

  \noindent
  Pomiary zamieszczone w dokumencie zostały wykonane na podstawie uśrednienia czasu realizacji trzydziestu obiegów programu. \\

  \noindent
  W ramach projektu zaimplementowano następujące algorytmy:
  - algorytm standaryzacji min-max
  - algorytm standaryzacji rozkładem normalnym
  - algorytm najbliższych sąsiadów (KNN)

  \noindent
  Algorytmy porównano na przykładowym zbiorze danych opisanym w następnym rozdziale.

  #+begin_export latex
    \clearpage
  #+end_export
* Informacje o sprzęcie na którym wykonano pomiar
  \noindent
  Model sprzętu:
  - Dell XPS 15 9570

  \noindent
  Procesor:
  - 12 x Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz, 3933 MHz

  \noindent
  Karta graficzna:
  - Nvidia GP107M GeForce GTX 1050 Ti Mobile

  #+begin_export latex
    \clearpage
  #+end_export
* Opis zbióru danych
  \noindent
  Dane pochodzą z archiwum [[https://archive.ics.uci.edu/ml/datasets/Skin+Segmentation][uci]]. Zawierają próbki kolorów G, R, B z wycinków obrazków twarzy ludzi w tym:
  - starych
  - młodych
  - w średnim wieku
  - o różnej rasie i kolorze skóry

  \noindent
  Sumaryczna liczba próbek wynosi 245057 z czego tylko 50859 próbek zawiera w sobie kolory twarzy. W danych istnieją też wycinki z różnych obrazków nie przedstawiających ludzi. \\

  \noindent
  Oryginalnie kolumna ostatnia zawierająca informację o przynależności kolorów G, R, B do twarzy miała następującą postać: \\

  \noindent
  *SKIN*:
  - ~1~ - twarz
  - ~2~ - nie twarz

  \noindent
  Dane zostały poddane wstępnej obróbce:
  1. Zamieniono kolumny tak, by odpowiadała kolejność R, G, B
  2. Zamieniono oznaczenie *SKIN* na:
     - ~0~ - nie twarz
     - ~1~ - twarz
  #+begin_export latex
  \clearpage
  #+end_export
* Implementacja
** Standaryzacja Min-Max
   Klasa ~MinMax~ zdefiniowana w pliku ~src/MinMax.cpp~ realizuje proces standaryzacji wartości w danej kolumnie do przedziału ~[0, 1]~. \\

   \noindent
   Standaryzacja ~min-max~ jest opisana wzorem
   #+begin_export latex
   \begin{equation}
   f(x) = {\frac{x - min(x)}{max(x) - min(x)}}
   \end{equation}
   #+end_export

*** Pomiar A
    #+BEGIN_SRC sh :results none :exports none :eval no
      make TB_SWITCH=1 THREADS=20 run_min_max && \
      make TB_SWITCH=1 THREADS=40 run_min_max && \
      make TB_SWITCH=1 THREADS=60 run_min_max && \
      make TB_SWITCH=1 THREADS=80 run_min_max && \
      make TB_SWITCH=1 THREADS=100 run_min_max && \
      make TB_SWITCH=1 THREADS=120 run_min_max
    #+end_src

    #+BEGIN_SRC sh :results none :exports none :eval no
      python3 visualize1.py min_max
    #+end_src

    #+CAPTION: Zależność czasu wykonania od threadów (blocks 12253)
    [[./resources/min_maxT1.png]]

    #+CAPTION: Zależność przyspieszenia od threadów (blocks 12253)
    [[./resources/min_maxT2.png]]

    #+BEGIN_SRC sh :results none :exports none :eval no
      make TB_SWITCH=0 BLOCKS=12260 run_min_max && \
      make TB_SWITCH=0 BLOCKS=13260 run_min_max && \
      make TB_SWITCH=0 BLOCKS=14260 run_min_max && \
      make TB_SWITCH=0 BLOCKS=15260 run_min_max && \
      make TB_SWITCH=0 BLOCKS=16260 run_min_max && \
      make TB_SWITCH=0 BLOCKS=17260 run_min_max
    #+end_src

    #+CAPTION: Zależność czasu wykonania od blocków (threads 20)
    [[./resources/min_maxB1.png]]

    #+CAPTION: Zależność przyspieszenia od blocków (threads 20)
    [[./resources/min_maxB2.png]]

    #+BEGIN_SRC sh :results none :exports none :eval no
      python3 visualize2.py min_max
    #+end_src
*** Pomiar B
    #+BEGIN_SRC sh :results output :exports results :eval no
      python3 min_max.py
    #+end_src

    #+RESULTS:
    : Mean of elapsed time for 30 execs took 75.01101126665617 ms

    #+begin_export latex
    \clearpage
    #+end_export
** Standaryzacja rozkładem normalnym
   Klasa ~StandardScaler~ zdefiniowana w pliku ~src/MinMax.cpp~ realizuje proces standaryzacji wartości w danej kolumnie do rozkładu normalnego ~N(0,1)~.
   Średnia wartość oczekiwana jest równa 0, a odchylenie standardowe wynosi 1. \\

   #+begin_export latex
    \begin{equation}
    \[Z = \frac{X-m}{\sigma} \sim N(0,1)\]
    \end{equation}
   #+end_export

*** Pomiar A
    #+BEGIN_SRC sh :results none :exports none :eval no
      make TB_SWITCH=1 THREADS=20 run_standard_scaler && \
      make TB_SWITCH=1 THREADS=40 run_standard_scaler && \
      make TB_SWITCH=1 THREADS=60 run_standard_scaler && \
      make TB_SWITCH=1 THREADS=80 run_standard_scaler && \
      make TB_SWITCH=1 THREADS=100 run_standard_scaler && \
      make TB_SWITCH=1 THREADS=120 run_standard_scaler
    #+end_src

    #+BEGIN_SRC sh :results none :exports none :eval no
      python3 visualize1.py standard_scaler
    #+end_src

    #+CAPTION: Zależność czasu wykonania od threadów (blocks 12253)
    [[./resources/standard_scalerT1.png]]

    #+CAPTION: Zależność przyspieszenia od threadów (blocks 12253)
    [[./resources/standard_scalerT2.png]]

    #+BEGIN_SRC sh :results none :exports none :eval no
      make TB_SWITCH=0 BLOCKS=12260 run_standard_scaler && \
      make TB_SWITCH=0 BLOCKS=13260 run_standard_scaler && \
      make TB_SWITCH=0 BLOCKS=14260 run_standard_scaler && \
      make TB_SWITCH=0 BLOCKS=15260 run_standard_scaler && \
      make TB_SWITCH=0 BLOCKS=16260 run_standard_scaler && \
      make TB_SWITCH=0 BLOCKS=17260 run_standard_scaler
    #+end_src

    #+BEGIN_SRC sh :results none :exports none :eval no
      python3 visualize2.py standard_scaler
    #+end_src

    #+CAPTION: Zależność czasu wykonania od blocków (threads 20)
    [[./resources/standard_scalerB1.png]]

    #+CAPTION: Zależność przyspieszenia od blocków (threads 20)
    [[./resources/standard_scalerB2.png]]
*** Pomiar B
    #+BEGIN_SRC sh :results output :exports results :eval no
      python3 standard_scaler.py
    #+end_src

    #+RESULTS:
    : Mean of elapsed time for 30 execs took 83.95475529996475 ms

    #+begin_export latex
    \clearpage
    #+end_export
** Klasyfikacja najblizszymi sąsiadami
   Klasa ~Knn~ zdefiniowana w pliku ~src/knn.cpp~ realizuje proces klasyfikacji przy użyciu algorytmu najbliższych sąsiadów. Dane na dwa zbiory, testowy (20%) i trenujący (80%), a do klasyfikacji używanych jest 5 sąsiadów, przy użyciu metryki euklidesowej. \\

   \noindent
   Liczba rekordów została zmniejszona do 5000.

   #+begin_export latex
    d(x) = \sqrt{\sum\limits_{i=1}^n(x_{iA}-x_{iB})^2} =\text{Odległość Euklidesowa}
   #+end_export

*** Pomiar A
    #+BEGIN_SRC sh :results none :exports none :eval no
      make TB_SWITCH=1 THREADS=20 run_knn && \
      make TB_SWITCH=1 THREADS=40 run_knn && \
      make TB_SWITCH=1 THREADS=60 run_knn && \
      make TB_SWITCH=1 THREADS=80 run_knn && \
      make TB_SWITCH=1 THREADS=100 run_knn && \
      make TB_SWITCH=1 THREADS=120 run_knn
    #+end_src

    #+BEGIN_SRC sh :results none :exports none :eval no
      python3 visualize1.py knn
    #+end_src

    #+CAPTION: Zależność czasu wykonania od threadów (blocks 12253)
    [[./resources/knnT1.png]]

    #+CAPTION: Zależność przyspieszenia od threadów (blocks 12253)
    [[./resources/knnT2.png]]

    #+BEGIN_SRC sh :results none :exports none :eval no
      make TB_SWITCH=0 BLOCKS=12260 run_knn && \
      make TB_SWITCH=0 BLOCKS=13260 run_knn && \
      make TB_SWITCH=0 BLOCKS=14260 run_knn && \
      make TB_SWITCH=0 BLOCKS=15260 run_knn && \
      make TB_SWITCH=0 BLOCKS=16260 run_knn && \
      make TB_SWITCH=0 BLOCKS=17260 run_knn
    #+end_src

    #+BEGIN_SRC sh :results none :exports none :eval no
      python3 visualize2.py knn
    #+end_src

    #+CAPTION: Zależność czasu wykonania od blocków (threads 20)
    [[./resources/knnB1.png]]

    #+CAPTION: Zależność przyspieszenia od blocków (threads 20)
    [[./resources/knnB2.png]]
*** Pomiar B
    #+BEGIN_SRC sh :results output :exports results :eval no
      python3 knn.py
    #+end_src

    #+RESULTS:
    : Total time  0.1096498966217041
    : Acurancy  0.996996996996997

    #+begin_export latex
      \clearpage
    #+end_export
* Wnioski
  \noindent
  Obserwując pomiary można zauważyć, iż wersja bez zastosowania ~OpenMP~ dla operacji cząstkowych budujących rozwiązanie końcowe jest około dwa razy wolniejsza od swojego zrównoleglonego odpowiednika. \\

  \noindent
  Przy tak małym zbiorze danych różnice jednak nie są znaczące. Zatem OpenMP jest jak najbardziej przydatne, ale tylko przy procesowaniu znaczącej ilości danych. \\

  \noindent
  *Wersje Pythonowe są 2 razy szybsze z oczywistych względów* \\
