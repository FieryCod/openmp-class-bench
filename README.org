#+title: Zrównoleglenie wstępnego przetwarzania danych przy użyciu OpenMPI
#+AUTHOR: Karol Wójcik, Krzysztof Swałdek
#+DATE: 2020-10-14, Wtorek

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [12pt]
#+LATEX_HEADER: \usepackage[a4paper, inner=37.125mm, outer=33.4125mm, top=37.125mm, bottom=37.125mm, heightrounded, marginparwidth=51pt, marginparsep=17pt, headsep=24pt]{geometry}
#+EXCLUDE_TAGS: noexport
#+LATEX_HEADER: \usepackage{graphicx}
#+LaTeX_HEADER: \usepackage[T1]{fontenc}
#+LaTeX_HEADER: \usepackage{mathpazo}
#+LaTeX_HEADER: \linespread{1.05}
#+LATEX_HEADER: \usepackage{setspace}
#+LATEX_HEADER: \doublespacing
#+LATEX_HEADER: \usepackage[polish]{babel}
#+LATEX_HEADER: \usepackage{polski}
#+LATEX_HEADER: \usepackage{listings}
#+LaTeX_HEADER: \lstset{basicstyle=\small\ttfamily}
#+LaTeX_HEADER: \usepackage{alltt}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LaTeX_HEADER: \usepackage{moreverb}
#+LATEX_HEADER: \usepackage{ragged2e}
#+LATEX_HEADER: \usepackage{xltxtra}
#+LaTeX_HEADER: \usepackage{pdfpages}
#+OPTIONS: ^:{}
#+LANGUAGE: pl
#+OPTIONS: toc:nil

#+begin_export latex
  \clearpage \tableofcontents \clearpage
#+end_export

* Wprowadzenie
Celem projektu jest implementacja popularnych algorytmów do przetwarzania danych, a także wykonanie i opis pomiaru czasowago wariantów algorytmów bez/z zrównolegleniem operując na środowisku MPI. \\

\noindent
W projekcie za wariant *A* uznaje się wersję algorytmu zrównoleglonego w c++. Za wersję *B* uznaje się wersję Pythonową algorytmu. \\

\noindent
Pomiary zamieszczone w dokumencie zostały wykonane na podstawie uśrednienia czasu realizacji trzydziestu obiegów programu. \\

\noindent
W ramach projektu zaimplementowano następujące algorytmy:
- algorytm standaryzacji min-max
- algorytm standaryzacji rozkładem normalnym
- algorytm najbliższych sąsiadów (KNN)

\noindent
Algorytmy porównano na przykładowym zbiorze danych opisanym w następnym rozdziale.

#+begin_export latex
  \clearpage
#+end_export
* Informacje o sprzęcie na którym wykonano pomiar
\noindent
Model sprzętu:
    - Dell XPS 15 9570

\noindent
Procesor:
    - 12 x Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz, 3933 MHz

\noindent
Karta graficzna:
    - Nvidia GP107M GeForce GTX 1050 Ti Mobile

#+begin_export latex
  \clearpage
#+end_export
* Opis zbióru danych
\noindent
Dane pochodzą z archiwum [[https://archive.ics.uci.edu/ml/datasets/Skin+Segmentation][uci]]. Zawierają próbki kolorów G, R, B z wycinków obrazków twarzy ludzi w tym:
  - starych
  - młodych
  - w średnim wieku
  - o różnej rasie i kolorze skóry

\noindent
Sumaryczna liczba próbek wynosi 245057 z czego tylko 50859 próbek zawiera w sobie kolory twarzy. W danych istnieją też wycinki z różnych obrazków nie przedstawiających ludzi. \\

\noindent
Oryginalnie kolumna ostatnia zawierająca informację o przynależności kolorów G, R, B do twarzy miała następującą postać: \\

\noindent
*SKIN*:
- ~1~ - twarz
- ~2~ - nie twarz

\noindent
Dane zostały poddane wstępnej obróbce:
1. Zamieniono kolumny tak, by odpowiadała kolejność R, G, B
2. Zamieniono oznaczenie *SKIN* na:
   - ~0~ - nie twarz
   - ~1~ - twarz
#+begin_export latex
\clearpage
#+end_export
* Implementacja
** Standaryzacja Min-Max
Klasa ~MinMax~ zdefiniowana w pliku ~src/MinMax.cpp~ realizuje proces standaryzacji wartości w danej kolumnie do przedziału ~[0, 1]~. \\

\noindent
Standaryzacja ~min-max~ jest opisana wzorem
#+begin_export latex
\begin{equation}
f(x) = {\frac{x - min(x)}{max(x) - min(x)}}
\end{equation}
#+end_export

*** Pomiar A
#+BEGIN_SRC sh :results none :exports none :eval no
  make PROCESSES=1 run_min_max && \
  make PROCESSES=2 run_min_max && \
  make PROCESSES=3 run_min_max && \
  make PROCESSES=4 run_min_max && \
  make PROCESSES=5 run_min_max && \
  make PROCESSES=6 run_min_max
#+end_src

#+CAPTION: Zależność czasu wykonania od liczby procesorów
[[./resources/min_max1.png]]

#+CAPTION: Zależność przyspieszenia wykonania od liczby procesorów
[[./resources/min_max2.png]]

#+BEGIN_SRC python :results none :exports none :eval no
python3 visualize.py min_max
#+end_src
*** Pomiar B
#+BEGIN_SRC sh :results output :exports results :eval no
python3 min_max.py
#+end_src

#+RESULTS:
: Mean of elapsed time for 30 execs took 75.01101126665617 ms

#+begin_export latex
\clearpage
#+end_export
** Standaryzacja rozkładem normalnym
Klasa ~StandardScaler~ zdefiniowana w pliku ~src/MinMax.cpp~ realizuje proces standaryzacji wartości w danej kolumnie do rozkładu normalnego ~N(0,1)~.
Średnia wartość oczekiwana jest równa 0, a odchylenie standardowe wynosi 1. \\

#+begin_export latex
\begin{equation}
\[Z = \frac{X-m}{\sigma} \sim N(0,1)\]
\end{equation}
#+end_export

*** Pomiar A
#+BEGIN_SRC sh :results none :exports none :eval no
  make PROCESSES=1 run_standard_scaler && \
  make PROCESSES=2 run_standard_scaler && \
  make PROCESSES=3 run_standard_scaler && \
  make PROCESSES=4 run_standard_scaler && \
  make PROCESSES=5 run_standard_scaler && \
  make PROCESSES=6 run_standard_scaler
#+end_src

#+CAPTION: Zależność czasu wykonania od liczby procesorów
[[./resources/standard_scaler1.png]]

#+CAPTION: Zależność przyspieszenia wykonania od liczby procesorów
[[./resources/standard_scaler2.png]]

#+BEGIN_SRC python :results none :exports none :eval no
python3 visualize.py standard_scaler
#+end_src

*** Pomiar B
#+BEGIN_SRC sh :results output :exports results :eval no
python3 standard_scaler.py
#+end_src

#+RESULTS:
: Mean of elapsed time for 30 execs took 83.95475529996475 ms

#+begin_export latex
\clearpage
#+end_export
** Klasyfikacja najblizszymi sąsiadami
Klasa ~Knn~ zdefiniowana w pliku ~src/knn.cpp~ realizuje proces klasyfikacji przy użyciu algorytmu najbliższych sąsiadów. Dane na dwa zbiory, testowy (20%) i trenujący (80%), a do klasyfikacji używanych jest 5 sąsiadów, przy użyciu metryki euklidesowej. \\

\noindent
Liczba rekordów została zmniejszona do 5000.

#+begin_export latex
d(x) = \sqrt{\sum\limits_{i=1}^n(x_{iA}-x_{iB})^2} =\text{Odległość Euklidesowa}
#+end_export

*** Pomiar A
#+BEGIN_SRC sh :results output :exports results :eval no
python3 knn.py
#+end_src

#+RESULTS:
: Total time  0.1289057731628418
: Acurancy  0.996996996996997

*** Pomiar B

#+begin_export latex
\clearpage
#+end_export
* Wnioski
\noindent
Obserwując pomiary można zauważyć, iż wersja bez zastosowania ~OpenMP~ dla operacji cząstkowych budujących rozwiązanie końcowe jest około dwa razy wolniejsza od swojego zrównoleglonego odpowiednika. \\

\noindent
Przy tak małym zbiorze danych różnice jednak nie są znaczące. Zatem OpenMP jest jak najbardziej przydatne, ale tylko przy procesowaniu znaczącej ilości danych. \\

\noindent
*Wersje Pythonowe są 2 razy szybsze z oczywistych względów* \\
